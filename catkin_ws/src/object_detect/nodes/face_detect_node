#!/usr/bin/env python

import cv2
import numpy as np
import cv_bridge
import json
import os
import rospy
import time

from std_msgs.msg import String
from sensor_msgs.msg import Image

PATH = os.path.dirname(__file__)

class FaceDetectNode(object):
    def __init__(self):
        rospy.init_node('face_detect_node')
        param_cascade = "haar/haarcascade_frontalface_default.xml"
        self.param_kx = 0.00035
        self.param_ky = 0.00035
        #param_cascade = "hs.xml"
        self.faceCascade = cv2.CascadeClassifier(os.path.join(param_cascade))
        self.sub_image = rospy.Subscriber("/camera/image_raw", Image, self.on_image, queue_size = 1)
        self.pub_detections = rospy.Publisher("/camera/detections", String, queue_size = 1)
        self.pub_animation = rospy.Publisher("/pwm/animation", String, queue_size = 1)
        self.is_processing = False
        self.request_target = None
        time.sleep(0.1)
        self.head = 0.5
        self.neck = 0.1

    def move(self, head = None, neck = None):
        if head is None:
            head = self.head
        if neck is None:
            neck = self.neck
        animation = [
            {"name": "head", "start_time": 0.0, "end_time": 0.07, "start_value": self.head, "end_value": head},
            {"name": "neck", "start_time": 0.0, "end_time": 0.07, "start_value": self.neck, "end_value": neck},
        ]
        self.pub_animation.publish(json.dumps([animation]))
        self.head = head
        self.neck = neck

    def on_image(self, msg):

        if self.is_processing:
            return

        self.is_processing = True

        t = time.time()
        image = cv_bridge.imgmsg_to_cv2(msg, "bgr8")
        image = cv2.resize(image, (320, 240))
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        detections = self.faceCascade.detectMultiScale(gray, 1.2, 5)

        m = String()
        detections_v = []
        for (x,y,w,h) in detections:
            detections_v.append([x,y,w,h])
        m.data = json.dumps(detections_v)
        self.pub_detections.publish(m)

        if len(detections) > 0:
            x = detections[0][0] + detections[0][2] / 2.0
            y = detections[0][1] + detections[0][3] / 2.0
            ox = x - image.shape[1] / 2.0
            oy = y - image.shape[0] / 2.0
            print("move to", ox, oy)
            self.request_target = ox * self.param_kx, oy * self.param_ky

        self.is_processing = False

    def spin(self):
        rate = rospy.Rate(8)
        while not rospy.is_shutdown():
            rate.sleep()
            if self.request_target is None:
                self.move()
            else:
                new_head = np.clip(self.head + self.request_target[0], 0.0, 1.0)
                new_neck = np.clip(self.neck + self.request_target[1], 0.0, 1.0)
                self.move(new_head, new_neck)
                self.request_target = None
        rospy.spin()

if __name__ == "__main__":
    node = FaceDetectNode()
    node.spin()
